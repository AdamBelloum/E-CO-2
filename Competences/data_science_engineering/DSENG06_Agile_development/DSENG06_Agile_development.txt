Agile software development describes a set of principles for software development under which requirements and solutions evolve through the collaborative effort of self-organizing cross-functional teams.[1] It promotes adaptive planning, evolutionary development, early delivery, and continuous improvement, and it encourages rapid and flexible response to change.[2] These principles support the definition and continuing evolution of many software development methods.[3]

The term agile was first coined for this in 2001, in the Manifesto for Agile Software Development (Agile Manifesto),[4] and although originally abbreviated as Agile (with a capital A) this is progressively becoming deprecated.[5]
Contents

    1 History
        1.1 The Agile Manifesto
        1.2 Evolutions
    2 Overview
        2.1 Iterative, incremental and evolutionary
        2.2 Efficient and face-to-face communication
        2.3 Very short feedback loop and adaptation cycle
        2.4 Quality focus
    3 Philosophy
        3.1 Adaptive vs. predictive
        3.2 Iterative vs. waterfall
        3.3 Code vs. documentation
    4 Agile methods
        4.1 Agile practices
        4.2 Method tailoring
        4.3 Comparison with other methods
        4.4 Large-scale, offshore and distributed
        4.5 Regulated domains
    5 Agile coaching
    6 Experience and adoption
        6.1 Common agile pitfalls
        6.2 Measuring agility
    7 Criticism
    8 Applications outside software development
    9 References
    10 Further reading
    11 External links

History

Incremental software development methods can be traced back to 1957.[6] Evolutionary project management[7] and adaptive software development[8][9] emerged in the early 1970s. During the 1990s, a number of lightweight software development methods evolved in reaction to the prevailing heavyweight methods that critics described as heavily regulated, regimented, and micro-managed. These included: from 1991, rapid application development;[10][11] from 1994, unified process and dynamic systems development method (DSDM); from 1995, Scrum; from 1996, Crystal Clear and extreme programming (XP); and from 1997, feature-driven development. Although these originated before the publication of the Agile Manifesto in 2001, they are now collectively referred to as agile methods.[3]
The Agile Manifesto

In February 2001, 17 software developers met at the Snowbird resort in Utah to discuss lightweight development methods. They published the Manifesto for Agile Software Development, in which they said that by "uncovering better ways of developing software by doing it and helping others do it," they have come to value "individuals and interactions over processes and tools, working software over comprehensive documentation, customer collaboration over contract negotiation, and responding to change over following a plan".[4]

    Individuals and interactions: self-organization and motivation are important, as are interactions like co-location and pair programming.
    Working software: working software is more useful and welcome than just presenting documents to clients in meetings.
    Customer collaboration: requirements cannot be fully collected at the beginning of the software development cycle, therefore continuous customer or stakeholder involvement is very important.
    Responding to change: agile methods are focused on quick responses to change and continuous development.[12]

Some of the authors formed the Agile Alliance, a non-profit organization that promotes software development according to the manifesto's values and principles. Introducing the manifesto on behalf of the Agile Alliance, Jim Highsmith said,

    The Agile movement is not anti-methodology, in fact many of us want to restore credibility to the word methodology. We want to restore a balance. We embrace modeling, but not in order to file some diagram in a dusty corporate repository. We embrace documentation, but not hundreds of pages of never-maintained and rarely-used tomes. We plan, but recognize the limits of planning in a turbulent environment. Those who would brand proponents of XP or SCRUM or any of the other Agile Methodologies as "hackers" are ignorant of both the methodologies and the original definition of the term hacker.
    — Jim Highsmith, History: The Agile Manifesto[13]

Agile principles

The Agile Manifesto is based on twelve principles:[14]

    Customer satisfaction by early and continuous delivery of valuable software
    Welcome changing requirements, even in late development
    Working software is delivered frequently (weeks rather than months)
    Close, daily cooperation between business people and developers
    Projects are built around motivated individuals, who should be trusted
    Face-to-face conversation is the best form of communication (co-location)
    Working software is the principal measure of progress
    Sustainable development, able to maintain a constant pace
    Continuous attention to technical excellence and good design
    Simplicity—the art of maximizing the amount of work not done—is essential
    Best architectures, requirements, and designs emerge from self-organizing teams
    Regularly, the team reflects on how to become more effective, and adjusts accordingly

Evolutions

Later, Ken Schwaber with others founded the Scrum Alliance and created the Certified Scrum Master programs and its derivatives. Schwaber left the Scrum Alliance in the fall of 2009, and founded Scrum.org.

In 2005, a group headed by Alistair Cockburn and Jim Highsmith wrote an addendum of project management principles, the Declaration of Interdependence,[15] to guide software project management according to agile software development methods.

In 2009, a movement by Robert C Martin wrote an extension of software development principles, the Software Craftsmanship Manifesto, to guide agile software development according to professional conduct and mastery.

In 2011 the original Agile Alliance[16] created the Guide to Agile Practices, an evolving open-source compendium of the working definitions of agile practices, terms, and elements, along with interpretations and experience guidelines from the world-wide community of agile practitioners.

Related disciplines, including project management (PRINCE2[17] and PMI[18]) and business analysis (IIBA[19]) have extended or updated their bodies of knowledge and certifications to embrace working with agile methods.
Overview
Pair programming, an agile development technique used by XP. Note information radiators in the background.

There are many specific agile development methods. Most promote teamwork, collaboration, and process adaptability throughout the product development life-cycle.
Iterative, incremental and evolutionary

Most agile development methods break product development work into small increments that minimize the amount of up-front planning and design. Iterations are short time frames (timeboxes) that typically last from one to four weeks. Each iteration involves a cross-functional team working in all functions: planning, analysis, design, coding, unit testing, and acceptance testing. At the end of the iteration a working product is demonstrated to stakeholders. This minimizes overall risk and allows the product to adapt to changes quickly.[20] An iteration might not add enough functionality to warrant a market release, but the goal is to have an available release (with minimal bugs) at the end of each iteration.[21] Multiple iterations might be required to release a product or new features.

Working software is the primary measure of progress.
Efficient and face-to-face communication

No matter which development method is followed, every team should include a customer representative (product owner in Scrum). This person is agreed by stakeholders to act on their behalf[22] and makes a personal commitment to being available for developers to answer questions throughout the iteration. At the end of each iteration, stakeholders and the customer representative review progress and re-evaluate priorities with a view to optimizing the return on investment (ROI) and ensuring alignment with customer needs and company goals.

In agile software development, an information radiator is a (normally large) physical display located prominently near the development team, where passers-by can see it. It presents an up-to-date summary of the product development status.[23][24] A build light indicator may also be used to inform a team about the current status of their product development.
Very short feedback loop and adaptation cycle

A common characteristic in agile development is the daily stand-up (also known as the daily scrum). In a brief session, team members report to each other what they did the previous day toward their team's iteration goal, what they intend to do today toward the goal, and any roadblocks or impediments they can see to the goal.[25]
Quality focus

Specific tools and techniques, such as continuous integration, automated unit testing, pair programming, test-driven development, design patterns, domain-driven design, code refactoring and other techniques are often used to improve quality and enhance product development agility.[26]
Philosophy

Compared to traditional software engineering, agile software development mainly targets complex systems and product development with dynamic, non-deterministic and non-linear characteristics, where accurate estimates, stable plans, and predictions are often hard to get in early stages—and big up-front designs and arrangements would probably cause a lot of waste, i.e., are not economically sound. These basic arguments and previous industry experiences, learned from years of successes and failures, have helped shape agile development's favor of adaptive, iterative and evolutionary development.[27]
Adaptive vs. predictive

Development methods exist on a continuum from adaptive to predictive.[28] Agile methods lie on the adaptive side of this continuum. One key of adaptive development methods is a "Rolling Wave" approach to schedule planning, which identifies milestones but leaves flexibility in the path to reach them, and also allows for the milestones themselves to change.[29] Adaptive methods focus on adapting quickly to changing realities. When the needs of a project change, an adaptive team changes as well. An adaptive team has difficulty describing exactly what will happen in the future. The further away a date is, the more vague an adaptive method is about what will happen on that date. An adaptive team cannot report exactly what tasks they will do next week, but only which features they plan for next month. When asked about a release six months from now, an adaptive team might be able to report only the mission statement for the release, or a statement of expected value vs. cost.

Predictive methods, in contrast, focus on analysing and planning the future in detail and cater for known risks. In the extremes, a predictive team can report exactly what features and tasks are planned for the entire length of the development process. Predictive methods rely on effective early phase analysis and if this goes very wrong, the project may have difficulty changing direction. Predictive teams often institute a change control board to ensure they consider only the most valuable changes.

Risk analysis can be used to choose between adaptive (agile or value-driven) and predictive (plan-driven) methods.[30] Barry Boehm and Richard Turner suggest that each side of the continuum has its own home ground, as follows:[31]
Home grounds of different development methods Agile methods 	Plan-driven methods 	Formal methods
Low criticality 	High criticality 	Extreme criticality
Senior developers 	Junior developers(?) 	Senior developers
Requirements change often 	Requirements do not change often 	Limited requirements, limited features see Wirth's law[clarification needed]
Small number of developers 	Large number of developers 	Requirements that can be modeled
Culture that responds to change 	Culture that demands order 	Extreme quality
Iterative vs. waterfall

One of the differences between agile and waterfall is the approach to quality and testing. In the waterfall model, there is always a separate testing phase after a build phase; however, in agile development testing is completed in the same iteration as programming.

Because testing is done in every iteration—which develops a small piece of the software—users can frequently use those new pieces of software and validate the value.

After the users know the real value of the updated piece of software, they can make better decisions about the software's future. Having a value retrospective and software re-planning session in each iteration—Scrum typically has iterations of just two weeks—helps the team continuously adapt its plans so as to maximize the value it delivers.

This iterative approach supports a product rather than a project mindset. This provides greater flexibility throughout the development process; whereas on projects the requirements are defined and locked down from the very beginning, making it difficult to change them later. Iterative product development allows the software to evolve in response to changes in business environment or market requirements.[32]

Because of the short iteration style of agile software development, it also has strong connections with the lean startup concept.
Code vs. documentation

In a letter to IEEE Computer, Steven Rakitin expressed cynicism about agile development, calling it "yet another attempt to undermine the discipline of software engineering" and translating "Working software over comprehensive documentation" as "We want to spend all our time coding. Remember, real programmers don't write documentation."[33]

This is disputed by proponents of agile software development, who state that developers should write documentation if that's the best way to achieve the relevant goals, but that there are often better ways to achieve those goals than writing static documentation.[34] Scott Ambler states that documentation should be "Just Barely Good Enough" (JBGE),[35] that too much or comprehensive documentation would usually cause waste, and developers rarely trust detailed documentation because it's usually out of sync with code,[34] while too little documentation may also cause problems for maintenance, communication, learning and knowledge sharing. Alistair Cockburn wrote of the Crystal Clear method:

    Crystal considers development a series of co-operative games, and intends that the documentation is enough to help the next win at the next game. The work products for Crystal include use cases, risk list, iteration plan, core domain models, and design notes to inform on choices...however there are no templates for these documents and descriptions are necessarily vague, but the objective is clear, just enough documentation for the next game. I always tend to characterize this to my team as: what would you want to know if you joined the team tomorrow.
    — Alistair Cockburn.[36]

Agile methods
Software development life-cycle support[37]

Agile methods support a broad range of the software development life cycle.[37] Some focus on the practices (e.g., XP, pragmatic programming, agile modeling), while some focus on managing the flow of work (e.g., Scrum, Kanban). Some support activities for requirements specification and development (e.g., FDD), while some seek to cover the full development life cycle (e.g., DSDM, RUP).

Popular agile software development frameworks include (but are not limited to):

    Adaptive software development (ASD)
    Agile modeling
    Agile Unified Process (AUP)
    Crystal Clear methods
    Disciplined agile delivery
    Dynamic systems development method (DSDM)
    Extreme programming (XP)
    Feature-driven development (FDD)
    Lean software development
    Kanban
    Scrum
    Scrumban

Agile practices

Agile development is supported by a number of concrete practices, covering areas like requirements, design, modelling, coding, testing, planning, risk management, process, quality, etc. Some notable agile practices include:

    Acceptance test-driven development (ATDD)
    Agile modeling
    Backlogs (Product and Sprint)
    Behavior-driven development (BDD)
    Business analyst designer method (BADM)[38]
    Cross-functional team
    Continuous integration (CI)
    Domain-driven design (DDD)
    Information radiators (scrum board, task board, visual management board, burndown chart)
    Iterative and incremental development (IID)
    Pair programming
    Planning poker
    Refactoring
    Scrum events (sprint planning, daily scrum, sprint review and retrospective)
    Test-driven development (TDD)
    Agile testing
    Timeboxing
    User story
    Story-driven modeling
    Retrospective
    Velocity tracking
    User Story Mapping

The Agile Alliance has provided a comprehensive online guide to applying agile these and other practices.[39]
Method tailoring

In the literature, different terms refer to the notion of method adaptation, including 'method tailoring', 'method fragment adaptation' and 'situational method engineering'. Method tailoring is defined as:

    A process or capability in which human agents determine a system development approach for a specific project situation through responsive changes in, and dynamic interplays between contexts, intentions, and method fragments.[40]

Potentially, almost all agile methods are suitable for method tailoring. Even the DSDM method is being used for this purpose and has been successfully tailored in a CMM context.[41] Situation-appropriateness can be considered as a distinguishing characteristic between agile methods and traditional software development methods, with the latter being relatively much more rigid and prescriptive. The practical implication is that agile methods allow product development teams to adapt working practices according to the needs of individual products. Practices are concrete activities and products that are part of a method framework. At a more extreme level, the philosophy behind the method, consisting of a number of principles, could be adapted (Aydin, 2004).[40]

Some approaches, such as Scrum and extreme programming, make the need for method adaptation explicit. With these less-prescriptive frameworks, one of the principles is that no single process fits every product development, but rather that practices should be tailored to the needs of the product.[37] Mehdi Mirakhorli[42] proposes a tailoring practice that provides a sufficient road-map and guidelines for adapting all the practices. RDP Practice is designed for customizing XP. This practice, first proposed as a long research paper in the APSO workshop at the ICSE 2008 conference, is currently the only proposed and applicable method for customizing XP. Although it is specifically a solution for XP, this practice has the capability of extending to other methodologies. At first glance, this practice seems to be in the category of static method adaptation but experiences with RDP Practice says that it can be treated like dynamic method adaptation. The distinction between static method adaptation and dynamic method adaptation is subtle.[43]

Scrum isn't designed for method tailoring. Schwaber notes that "Scrum is not a methodology that needs enhancing. That is how we got into trouble in the first place, thinking that the problem was not having a perfect methodology. Effort centers on the changes in the enterprise that is needed."[44] Bas Vodde reinforces this statement, suggesting that Scrum isn't like traditional, large methodologies that require you to "pick and choose" elements. It is the basics on top of which you add additional elements to localise and contextualise its use.[45]
Comparison with other methods
RAD

Agile methods have much in common with the Rapid Application Development techniques from the 1980/90s as espoused by James Martin and others. In addition to technology-focused methods, customer-and-design-centered methods, such as Visualization-Driven Rapid Prototyping developed by Brian Willison, work to engage customers and end users to facilitate agile software development.[46]

Further, James M. Kerr and Richard Hunter wrote a book on the subject that presented a day-by-day diary of a real RAD development. It covered work right from inception through to production and contains many of the techniques that forge the backbone of, and are very much present in, today's agile product development approaches.[47]
CMMI

In 2008 the Software Engineering Institute (SEI) published the technical report "CMMI or Agile: Why Not Embrace Both"[48] to make clear that the Capability Maturity Model Integration and agile methods can co-exist. Modern CMMI-compatible development processes are also iterative. The CMMI Version 1.3 includes tips for implementing CMMI and agile process improvement together.[49]
DevOps

Organizations that adopt agile development see more frequent releases; which led to the concepts of continuous delivery and DevOps.[50] While DevOps and agile software development both embody many Lean philosophies, such as collaboration and communication, they are distinct concepts. While agile principles represent a change in thinking, DevOps seeks to implement actual organizational cultural change.[51][52]
Large-scale, offshore and distributed

Agile development has been widely seen as highly suited to certain types of environments, including small teams of experts working on greenfield projects,[31][53]:157 and the challenges and limitations encountered in the adoption of agile methods in a large organization with legacy infrastructure are well-documented and understood.[54]

In response, a range of strategies and patterns has evolved for overcoming challenges with large-scale development efforts (>20 developers)[55][56] or distributed (non-colocated) development teams,[57][58] amongst other challenges; and there are now several recognised frameworks that seek to mitigate or avoid these challenges, including:

    Scaled Agile Framework (SAFe),[59] Dean Leffingwell inter alia
    Disciplined agile delivery (DAD), Scott Ambler inter alia
    Large-scale scrum (LeSS), Craig Larman and Bas Vodde
    Nexus (scaled professional Scrum),[60] Ken Schwaber
    Scrum at Scale,[61] Jeff Sutherland, Alex Brown
    Enterprise Scrum,[62] Mike Beedle
    Setchu (Scrum-based lightweight framework),[63] Michael Ebbage
    Xscale[64]
    Agile path[65]
    Holistic Software Development [66]

There are many conflicting viewpoints on whether all of these are effective or indeed fit the definition of agile development, and this remains an active and ongoing area of research.[55][67]

When agile software development is applied in a distributed setting (with teams dispersed across multiple business locations), it is commonly referred to as distributed agile development. The goal is to leverage the unique benefits offered by each approach. Distributed development allow organizations to build software by strategically setting up teams in different parts of the globe, virtually building software round-the-clock (more commonly referred to as follow-the-sun model). On the other hand, agile development provides increased transparency, continuous feedback and more flexibility when responding to changes.
Regulated domains

Agile methods were initially seen as best suitable for non-critical product developments, thereby excluded from use in regulated domains such as medical devices, pharmaceutical, financial, nuclear systems, automotive, and avionics sectors, etc. However, in the last several years, there have been several initiatives for the adaptation of agile methods for these domains.[68][69][70]

There are numerous standards that may apply in regulated domains, including ISO 26262, ISO 9000, ISO 9001, and ISO/IEC 15504. A number of key concerns are of particular importance in regulated domains which may conflict with the use of agile methods:[68]

    Quality Assurance (QA): Systematic and inherent quality management underpinning a controlled professional process and reliability and correctness of product.
    Safety and Security: Formal planning and risk management to mitigate safety risks for users and securely protecting users from unintentional and malicious misuse.
    Traceability: Documentation providing auditable evidence of regulatory compliance and facilitating traceability and investigation of problems.
    Verification and Validation (V&V): Embedded throughout the software development process (e.g. user requirements specification, functional specification, design specification, code review, unit tests, integration tests, system tests).

The Scrum framework in particular has received considerable attention. Two derived methods have been defined: R-Scrum (Regulated Scrum)[68] and SafeScrum.[71][72]
Agile coaching

Teams and organizations choosing to adopt more agile ways of working typically undertake an agile transformation with the support of one or more agile coaches. The agile coach guides teams through the transformation. There are typically two styles of agile coaching: push based and pull-based agile coaching.
Experience and adoption

Agile methods were first used by technology early adopters such as Tektronix. Although agile methods can be used with any programming paradigm or language in practice, they were originally closely associated with object-oriented environments such as Smalltalk and Lisp and later Java. The initial adopters of agile methods were usually small to medium-sized teams working on unprecedented systems with requirements that were difficult to finalize and likely to change as the system was being developed. This section describes common problems that organizations encounter when they try to adopt agile methods as well as various techniques to measure the quality and performance of agile teams.[73]
Common agile pitfalls

Organizations and teams implementing agile development often face difficulties transitioning from more traditional methods such as waterfall development, such as teams having an agile process forced on them.[74] These are often termed agile anti-patterns or more commonly agile smells. Below are some common examples:
Lack of overall product design

A goal of agile software development is to focus more on producing working software and less on documentation. This is in contrast to waterfall models where the process is often highly controlled and minor changes to the system require significant revision of supporting documentation. However, this does not justify completely doing without any analysis or design at all. Failure to pay attention to design can cause a team to proceed rapidly at first but then to have significant rework required as they attempt to scale up the system. One of the key features of agile software development is that it is iterative. When done correctly design emerges as the system is developed and commonalities and opportunities for re-use are discovered.[75]
Adding stories to an iteration in progress

In agile software development, stories (similar to use case descriptions) are typically used to define requirements and an iteration is a short period of time during which the team commits to specific goals.[76] Adding stories to an iteration in progress is detrimental to a good flow of work. These should be added to the product backlog and prioritized for a subsequent iteration or in rare cases the iteration could be cancelled.[77]

This does not mean that a story cannot expand. Teams must deal with new information, which may produce additional tasks for a story. If the new information prevents the story from being completed during the iteration, then it should be carried over to a subsequent iteration. However, it should be prioritized against all remaining stories, as the new information may have changed the story's original priority.
Lack of sponsor support

Agile software development is often implemented as a grassroots effort in organizations by software development teams trying to optimize their development processes and ensure consistency in the software development life cycle. By not having sponsor support, teams may face difficulties and resistance from business partners, other development teams and management. Additionally, they may suffer without appropriate funding and resources.[78] This increases the likelihood of failure.[79]
Insufficient training

A survey performed by Version One found respondents cited insufficient training as the most significant cause for failed agile implementations[80] Teams have fallen into the trap of assuming the reduced processes of agile development compared to other methodologies such as waterfall means that there are no actual rules for agile development. Agile development is a set of prescribed methodologies, and training/practice is a requirement.
Product owner role is not properly filled

The product owner is responsible for representing the business in the development activity and is often the most demanding role.[81]

A common mistake is to have the product owner role filled by someone from the development team. This requires the team to make its own decisions on prioritization without real feedback from the business. They try to solve business issues internally or delay work as they reach outside the team for direction. This often leads to distraction and a breakdown in collaboration.[82]
Teams are not focused

The agile process requires teams to meet product commitments, which means they should focus only on work for that product. However, team members who are seen as have spare capacity are often expected to take on other work, which means it is then difficult for them to help complete the work to which their team had commmited.[83]
Excessive preparation/planning

Teams may fall into the trap of spending too much time preparing or planning. This is a common trap for teams less familiar with the agile process where the teams feel obligated to have a complete understanding and specification of all stories. Teams should be prepared to move forward only with those stories in which they have confidence, then during the iteration continue discovery (sometimes referred to as refinement or grooming) to help inform work for subsequent iterations.
Problem-solving in the daily standup

A daily standup should be a focused, timely meeting where all team members disseminate information. If problem-solving occurs, it often can only involve certain team members and potentially is not the best use of the entire team's time. If during the daily standup the team starts diving into problem-solving, it should be tabled until a sub-team can discuss, usually immediately after the standup completes.[84]
Assigning tasks

One of the intended benefits of agile development is to empower the team to make choices, as they are closest to the problem. Additionally, they should make choices as close to implementation as possible, to use more timely information in the decision. If team members are assigned tasks by others or too early in the process, the benefits of localized and timely decision making can be lost.[85]

Being assigned work also constrains team members into certain roles (for example, team member A must always do the database work), which limits opportunities for cross-training.[85] Team members themselves can choose to take on tasks that stretch their abilities and provide cross-training opportunities.
Scrum master as a contributor

Another common pitfall is for a scrum master to act as a contributor. While not prohibited by the Scrum methodology, the scrum master needs to ensure they have the capacity to act in the role of scrum master first and not working on development tasks. A scrum master's role is to facilitate the process rather than create the product.[86]

Having the scrum master also multitasking may result in too many context switches to be productive. Additionally, as a scrum master is responsible for ensuring roadblocks are removed so that the team can make forward progress, the benefit gained by individual tasks moving forward may not outweigh roadblocks that are deferred due to lack of capacity.[86]
Lack of test automation

Due to the iterative nature of agile development, multiple rounds of testing are often needed. Automated testing helps reduce the impact of repeated unit, integration, and regression tests and frees developers and testers to focus on higher value work.[87]

Test automation also supports continued refactoring required by iterative software development. Allowing a developer to quickly run tests to confirm refactoring has not modified the functionality of the application may reduce the workload and increase confidence that cleanup efforts have not introduced new defects.
Allowing technical debt to build up

Focusing on delivering new functionality may result in increased technical debt. The team must allow themselves time for defect remediation and refactoring. Technical debt hinders planning abilities by increasing the amount of unscheduled work as production defects distract the team from further progress.[88]

As the system evolves it is important to refactor as entropy of the system naturally increases.[89] Over time the lack of constant maintenance causes increasing defects and development costs.[88]
Attempting to take on too much in an iteration

A common misconception is that agile development allows continuous change, however an iteration backlog is an agreement of what work can be completed during an iteration.[90] Having too much work-in-progress (WIP) results in inefficiencies such as context-switching and queueing.[91] The team must avoid feeling pressured into taking on additional work.[92]
Fixed time, resources, scope, and quality

Agile development fixes time (iteration duration), quality, and ideally resources in advance (though maintaining fixed resources may be difficult if developers are often pulled away from tasks to handle production incidents), while the scope remains variable. The customer or product owner often pushes for a fixed scope for an iteration. However, teams should be reluctant to commit to locked time, resources and scope (commonly known as the project management triangle). Efforts to add scope to the fixed time and resources of agile development may result in decreased quality.[93]
Measuring agility

The best agile practitioners have always emphasized sound engineering principles. As a result, there are a number of agile best practices and tools for measuring the performance of product development and teams.

The Agility Index Measurements (AIM)[94] scores product development against a number of agility factors to achieve a total. The similarly named Agility Measurement Index,[95] scores developments against five dimensions of product development (duration, risk, novelty, effort, and interaction). Other techniques are based on measurable goals.[96] Another study using fuzzy mathematics[97] has suggested that velocity can be used as a metric of agility. There are agile self-assessments to determine whether a team is using agile practices (Nokia test,[98] Karlskrona test,[99] 42 points test[100]).

While such approaches have been proposed to measure agility, the practical application of such metrics is still debated. Agile software development ROI data is available from the CSIAC ROI Dashboard.[101]
Surveys

One of the early studies reporting gains in quality, productivity, and business satisfaction by using agile methods was a survey conducted by Shine Technologies from November 2002 to January 2003.[102]

A similar survey, the State of Agile, is conducted every year starting in 2006 with thousands of participants from around the software development community. This tracks trends on the benefits of agile, lessons learned, and good practices. Each survey has reported increasing numbers saying that agile development helps them deliver software faster; improves their ability to manage changing customer priorities; and increases their productivity.[103] Surveys have also consistently shown better results with agile product development methods compared to classical project management.[104][105] In balance, there are reports that some feel that agile development methods are still too young to enable extensive academic research of their success.[106]
Criticism

Agile methodologies can be inefficient in large organizations and certain types of developments.[107] Agile methods seem best for early-stage non-sequential product development. Many organizations believe that agile methodologies are too extreme and adopt a hybrid approach that mixes elements of agile and plan-driven approaches.[108] Some methods, such as DSDM, have combined elements of agile and plan-driven approaches in a disciplined way, without sacrificing the fundamental principles that make agile work.

The term "agile" has also been criticized as being a management fad that simply describes existing good practices under new jargon, promotes a "one size fits all" mindset towards development strategies, and wrongly emphasizes method over results.[109]

Alistair Cockburn organized a celebration of the 10th anniversary of the Agile Manifesto in Snowbird, Utah on February 12, 2011, gathering some 30+ people who had been involved at the original meeting and since. A list of about 20 elephants in the room ("undiscussable" agile topics/issues) were collected, including aspects: the alliances, failures and limitations of agile practices and context (possible causes: commercial interests, decontextualization, no obvious way to make progress based on failure, limited objective evidence, cognitive biases and reasoning fallacies), politics and culture.[110] As Philippe Kruchten wrote:

    The agile movement is in some ways a bit like a teenager: very self-conscious, checking constantly its appearance in a mirror, accepting few criticisms, only interested in being with its peers, rejecting en bloc all wisdom from the past, just because it is from the past, adopting fads and new jargon, at times cocky and arrogant. But I have no doubts that it will mature further, become more open to the outside world, more reflective, and also therefore more effective.

Applications outside software development
Agile Brazil 2014 conference

Agile methods have been extensively used for development of software products and some of them use certain characteristics of software, such as object technologies.[111] However, these techniques can be applied to the development of non-software products, such as computers, motor vehicles,[112] medical devices, food, clothing, and music;[113] see Flexible product development. Agile methods have been used in non-development IT infrastructure deployments and migrations. Some of the wider principles of agile have also found application in general management[114] (e.g., strategy, governance, risk, finance) under the terms business agility or agile business management. Agile principles are also used in marketing.[115]

Under an agile business management model, agile techniques, practices, principles and values are expressed across five domains.[116]

    Integrated customer engagement – to embed customers within any delivery process to share accountability for product/service delivery.
    Facilitation-based management – adopting agile management models, like the role of Scrum Master, to facilitate the day-to-day operation of teams.
    Agile work practices – adopting specific iterative and incremental work practices such as Scrum, Kanban, test-driven development or feature-driven development across all business functions (from sales, human resources, finance[117] and Marketing).
    An enabling organisational structure – with a focus on staff engagement, personal autonomy and outcomes based governance.
    An education model 
    that blends agile practices and philosophies to create micro-schools that emphasize collaborative culture creation and self-directed learning.

Agile development paradigms can be used in other areas of life such as raising children. Its success in child development might be founded on some basic management principles; communication, adaptation and awareness. Bruce Feiler has claimed that the basic agile development paradigms can be applied to household management and raising children. In his TED Talk "Agile programming – for your family",[118] these paradigms brought significant changes to his household environment, such as the kids doing dishes, taking out the trash, and decreasing his children's emotional outbreaks, which inadvertently increased their emotional stability.




